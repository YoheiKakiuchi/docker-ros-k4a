;;!/usr/bin/env roseus

(ros::roseus-add-msgs "visualization_msgs")
(ros::roseus-add-msgs "sensor_msgs")
(ros::roseus-add-msgs "opencv_apps")
(ros::roseus-add-msgs "image_view2")

;; start ros
;;(ros::roseus "azure_kinect_parser" :anonymous nil)
(ros::advertise "/image_marker" image_view2::ImageMarker2)

(setq body-map '((0 "PELVIS" nil)
                 (1 "SPINE_NAVAL" "PELVIS")
                 (2 "SPINE_CHEST" "SPINE_NAVAL")
                 (3 "NECK" "SPINE_CHEST")
                 (4 "CLAVICLE_LEFT" "SPINE_CHEST")
                 (5 "SHOULDER_LEFT" "CLAVICLE_LEFT")
                 (6 "ELBOW_LEFT" "SHOULDER_LEFT")
                 (7 "WRIST_LEFT" "ELBOW_LEFT")
                 (8 "HAND_LEFT" "WRIST_LEFT")
                 (9 "HANDTIP_LEFT" "HAND_LEFT")
                 (10 "THUMB_LEFT" "WRIST_LEFT")
                 (11 "CLAVICLE_RIGHT" "SPINE_CHEST")
                 (12 "SHOULDER_RIGHT" "CLAVICLE_RIGHT")
                 (13 "ELBOW_RIGHT" "SHOULDER_RIGHT")
                 (14 "WRIST_RIGHT" "ELBOW_RIGHT")
                 (15 "HAND_RIGHT" "WRIST_RIGHT")
                 (16 "HANDTIP_RIGHT" "HAND_RIGHT")
                 (17 "THUMB_RIGHT" "WRIST_RIGHT")
                 (18 "HIP_LEFT" "PELVIS")
                 (19 "KNEE_LEFT" "HIP_LEFT")
                 (20 "ANKLE_LEFT" "KNEE_LEFT")
                 (21 "FOOT_LEFT" "ANKLE_LEFT")
                 (22 "HIP_RIGHT" "PELVIS")
                 (23 "KNEE_RIGHT" "HIP_RIGHT")
                 (24 "ANKLE_RIGHT" "KNEE_RIGHT")
                 (25 "FOOT_RIGHT" "ANKLE_RIGHT")
                 (26 "HEAD" "NECK")
                 (27 "NOSE" "HEAD")
                 (28 "EYE_LEFT" "HEAD")
                 (29 "EAR_LEFT" "HEAD")
                 (30 "EYE_RIGHT" "HEAD")
                 (31 "EAR_RIGHT" "HEAD")))

(defun head-position (person)
  (let ((p (float-vector 0 0 0))
        (q0 (elt person 27))
        (q1 (elt person 28))
        (q2 (elt person 30))
        )
    (when (or q0 q1 q2)
      (if q0 (v+ (send (send (send q0 :copy-worldcoords) :transform *depth-on-world* :world) :worldpos) p p))
      (if q1 (v+ (send (send (send q1 :copy-worldcoords) :transform *depth-on-world* :world) :worldpos) p p))
      (if q2 (v+ (send (send (send q2 :copy-worldcoords) :transform *depth-on-world* :world) :worldpos) p p))
      (scale (/ 1.0 3) p p)
      p)
    ))
(defun left-hand-position (person)
  (let ((p (float-vector 0 0 0))
        (q0 (elt person 8))
        (q1 (elt person 9))
        )
    (when (or q0 q1)
      (if q0 (v+ (send (send (send q0 :copy-worldcoords) :transform *depth-on-world* :world) :worldpos) p p))
      (if q1 (v+ (send (send (send q1 :copy-worldcoords) :transform *depth-on-world* :world) :worldpos) p p))
      (scale (/ 1.0 3) p p)
      p)
    ))
(defun right-hand-position (person)
  (let ((p (float-vector 0 0 0))
        (q0 (elt person 15))
        (q1 (elt person 16))
        )
    (when (or q0 q1)
      (if q0 (v+ (send (send (send q0 :copy-worldcoords) :transform *depth-on-world* :world) :worldpos) p p))
      (if q1 (v+ (send (send (send q1 :copy-worldcoords) :transform *depth-on-world* :world) :worldpos) p p))
      (scale (/ 1.0 3) p p)
      p)
    ))
(defun head-pixel (person)
  (let ((p (float-vector 0 0 0))
        (q0 (elt person 27))
        (q1 (elt person 28))
        (q2 (elt person 30))
        )
    (when (or q0 q1 q2)
      (if q0 (v+ (send q0 :worldpos) p p))
      (if q1 (v+ (send q1 :worldpos) p p))
      (if q2 (v+ (send q2 :worldpos) p p))
      (scale (/ 1.0 3) p p)
      (setq p (send *cds-rgb-depth* :transform-vector p))
      (send *rgb-cam* :screen-point p)
      )
    ))
(defun left-hand-pixel (person)
  (let ((p (float-vector 0 0 0))
        (q0 (elt person 8))
        (q1 (elt person 9))
        )
    (when (or q0 q1)
      (if q0 (v+ (send q0 :worldpos) p p))
      (if q1 (v+ (send q1 :worldpos) p p))
      (scale (/ 1.0 3) p p)
      (setq p (send *cds-rgb-depth* :transform-vector p))
      (send *rgb-cam* :screen-point p)
      )
    ))
(defun right-hand-pixel (person)
  (let ((p (float-vector 0 0 0))
        (q0 (elt person 15))
        (q1 (elt person 16))
        )
    (when (or q0 q1)
      (if q0 (v+ (send q0 :worldpos) p p))
      (if q1 (v+ (send q1 :worldpos) p p))
      (setq p (send *cds-rgb-depth* :transform-vector p))
      (send *rgb-cam* :screen-point p)
      )
    ))
(defun body-coords (person)
  (let((cds0 (elt person 0))
       (cds1 (elt person 1))
       (cds2 (elt person 2))
       )
    ))

(setq *recog-person* nil)
(defun tracking-callback (mak)
  (setq *recog-person* (instantiate vector 5))
  (let (debug-list cur-pid first-pid)
    (dolist (m (send mak :markers))
      (let* ((id (send m :id))
             (person-id (/ id 100))
             (parts-id  (mod id 100))
             (cds (ros::tf-pose->coords (send m :pose)))
             )
        (if (not first-pid) (setq first-pid person-id))
        (if (>= (- person-id first-pid) 0)
            (setq cur-pid (- person-id first-pid))
          (setq cur-pid person-id))
        (unless (> cur-pid 4)
          (send cds :put :parts  parts-id)
          (send cds :put :person person-id)
          ;;(send cds :transform   *depth-on-world* :world)
          #|
          (when (memq parts-id (list 0 26 5 9 12 16 21 25))
            ;; debug
            (let ((ar (arrow)))
              (send ar :transform cds)
              (push ar debug-list))
            )
          |#
          ;;
          (let ((p (elt *recog-person* cur-pid)))
            (cond
             (p (setf (elt p parts-id) cds))
             (t
              (setq p (instantiate vector 32))
              (setf (elt p parts-id) cds)
              (setf (elt *recog-person* cur-pid) p))
             ))
          ;;(pprint cur-pid)
          ;;(pprint (elt *recog-person* cur-pid))
          #|
          (pprint (list person-id
                        (head-position (elt *recog-person* cur-pid))
                        (left-hand-position (elt *recog-person* cur-pid))
                        (right-hand-position (elt *recog-person* cur-pid))
                        ))
          |#
          )
        ))
    ;; debug
    ;;(pprint debug-list)
    ;;(pprint *depth-on-world*)
    (when debug-list
      (send *irtviewer* :objects debug-list)
      (send *irtviewer* :draw-objects)
      )
    ))

(setq *depth-on-world* (make-coords))
(defun imu-callback (imu)
  (let ((cds
         (orient-coords-to-axis (make-coords) (float-vector 0 0 1)
                                (let ((la (send imu :linear_acceleration)))
                                  (normalize-vector
                                   (float-vector (send la :x) (send la :y) (send la :z))))
                                1e-10)))
    ;;
    (setq *depth-on-world* (send cds :transform *cds-imu-depth*))
    ))

(ros::subscribe "/k4a/imu" sensor_msgs::Imu #'imu-callback 1)
(ros::subscribe "/k4a/body_tracking_data" visualization_msgs::MarkerArray #'tracking-callback 1)

(defun parse-green-moments (msg)
  (let ((max-area 0)
        (max-mmt nil))
    (dolist (moment (send msg :moments))
      (when (> (send moment :area) max-area)
        (setq max-area (send moment :area))
        (setq max-mmt moment))
      )
    (when (> max-area 200)
      (send max-mmt :put :header (send msg :header))
      (setq *green-moment* max-mmt)
      )
    ))
(defun parse-purple-moments (msg)
  (let ((max-area 0)
        (max-mmt nil))
    (dolist (moment (send msg :moments))
      (when (> (send moment :area) max-area)
        (setq max-area (send moment :area))
        (setq max-mmt moment))
      )
    (when (> max-area 200)
      (send max-mmt :put :header (send msg :header))
      (setq *purple-moment* max-mmt)
      )
    ))
;;(send moment :center :x)
;;(send moment :center :y)

(setq *green-moment* nil)
(setq *purple-moment* nil)
(ros::subscribe "/kinect_aux/green_card/contour_moments/moments"  opencv_apps::MomentArrayStamped #'parse-green-moments 3)
(ros::subscribe "/kinect_aux/purple_card/contour_moments/moments" opencv_apps::MomentArrayStamped #'parse-purple-moments 3)

(setq *tfl* (instance ros::transform-listener :init))
;; imu -> depth_camera
(send *tfl* :wait-for-transform "azure_imu_link" "azure_depth_camera_link" (ros::time 0) 2.0)
(setq *cds-imu-depth* (send *tfl* :lookup-transform "azure_imu_link" "azure_depth_camera_link" (ros::time 0)))
(setq *cds-rgb-depth* (send *tfl* :lookup-transform "azure_rgb_camera_link" "azure_depth_camera_link" (ros::time 0)))

(setq *rgb-cam*  (make-camera-from-param :pwidth 1280 :pheight 720
                                         :fx 612.4671630859375 :fy 612.417724609375
                                         :cx 639.3863525390625 :cy 364.351318359375))

(defun set-roi-func (hp)
  (let ((req (instance dynamic_reconfigure::ReconfigureRequest :init))
        (xx (elt hp 0))
        (yy (elt hp 1))
        )
    ;; 1280 720 -> 480 480
    (cond
     ((> xx (- 1280 240))
      (setq xx 800)) ;; - 1280 480
     ((< xx 240)
      (setq xx 0))
     (t
      (setq xx (floor (- xx 240)))
      ))
    (cond
     ((> yy (- 720 240))
      (setq yy 240)) ;; - 720 480
     ((< yy 240)
      (setq yy 0))
     (t
      (setq yy (floor (- yy 240)))
      ))
    (pprint (list xx yy))
    (send req :config :ints
          (list (instance dynamic_reconfigure::IntParameter :init
                          :name "x_offset" :value xx)
                (instance dynamic_reconfigure::IntParameter :init
                          :name "y_offset" :value yy)
                (instance dynamic_reconfigure::IntParameter :init
                          :name "width" :value 480)
                (instance dynamic_reconfigure::IntParameter :init
                          :name "height" :value 480)
                ))
    (ros::service-call "/k4a/crop_decimate/set_parameters" req)
    ))

;;(load "models/arrow-object.l")
;;(make-irtviewer)
(defun main (&key (set-roi))
  (ros::rate 5)
  (while (ros::ok)
    ;;
    (when *recog-person*
      ;;
      (let ((mrk (instance image_view2::ImageMarker2 :init))
            (recog-p (elt *recog-person* 0)))
        (when recog-p
          (let ((rp (right-hand-pixel recog-p))
                (lp (left-hand-pixel  recog-p))
                (hp (head-pixel       recog-p)))
        #|
        (when rp
          (send mrk :type image_view2::ImageMarker2::*POINTS*)
          (send mrk :points (list (instance geometry_msgs::Point :init :x (elt rp 0) :y (elt rp 1))))
          (send mrk :scale 16.0)
          (ros::publish "/image_marker" mrk)
          )
        (when lp
          (send mrk :type image_view2::ImageMarker2::*POINTS*)
          (send mrk :points (list (instance geometry_msgs::Point :init :x (elt lp 0) :y (elt lp 1))))
          (send mrk :scale 16.0)
          (ros::publish "/image_marker" mrk)
          )
        (when hp
          (send mrk :type image_view2::ImageMarker2::*POINTS*)
          (send mrk :points (list (instance geometry_msgs::Point :init :x (elt hp 0) :y (elt hp 1))))
          (send mrk :scale 16.0)
          (ros::publish "/image_marker" mrk)
          )
        |#
            (if (and set-roi hp) (set-roi-func hp))
            )
          ))
      )
    #|
    (when *purple-moment* )

    (when *green-moment* )
    |#
    ;;
    (if *recog-person*  (setq *recog-person* nil))
    (if *green-moment*  (setq *green-moment* nil))
    (if *purple-moment* (setq *purple-moment* nil))
    ;;
    (ros::spin-once)
    ;; (x::window-main-one)
    (ros::sleep)
    )
  )
